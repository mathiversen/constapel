use std::path::PathBuf;
use structopt::StructOpt;
use std::fs::{File, OpenOptions};
use std::io::prelude::*;
use serde_json::Value;

type Result<T> = std::result::Result<T, std::boxed::Box<dyn std::error::Error>>;

#[derive(Debug, StructOpt)]
#[structopt(name = "example", about = "An example of StructOpt usage.")]
struct Opt {
    #[structopt(parse(from_os_str))]
    input: PathBuf,
    #[structopt(long = "js")]
    output_js: Option<PathBuf>,
    #[structopt(long = "css")]
    output_css: Option<PathBuf>,
    #[structopt(long = "scss")]
    output_scss: Option<PathBuf>,
}

const DONT_EDIT_COPY: &'static str = "DO NOT EDIT THIS FILE - IT IS GENERATED";

fn create_scss_files(name: &str, value: &Value, path: &PathBuf) -> Result<()> {
    let mut file_css = File::create(format!("{}/_{}.scss", &path.to_string_lossy(), &name))?;
    file_css.write_all(format!("// {}\n\n", DONT_EDIT_COPY).as_bytes())?;
    for v in value.as_object().expect("Failed to parse value") {
        let x = match v.1 {
            Value::String(x) => format!("${}: {};\n", v.0, x.replace("\"", "")),
            Value::Number(x) => format!("${}: {};\n", v.0, x),
            _ => panic!("Only strings and numbers have been implemented for"),
        };
        file_css.write_all(x.as_bytes())?;
    }
    Ok(())
}

fn create_css_files(value: &Value, path: &PathBuf, is_last: bool) -> Result<()> {
    let file_path = format!("{}root.css", &path.to_string_lossy());
    let file_exist = File::open(&file_path).is_ok();
    let mut file = match file_exist {
        true => OpenOptions::new()
            .write(true)
            .append(true)
            .open(&file_path)?,
        false => File::create(&file_path)?,
    };
    if !file_exist {
        &file.write_all(format!("/* {} */\n\n", DONT_EDIT_COPY).as_bytes())?;
        &file.write_all(":root {\n".as_bytes())?;
    }
    for v in value.as_object().expect("Failed to parse value") {
        let x = match v.1 {
            Value::String(x) => format!("    --{}: {};\n", v.0, x.replace("\"", "")),
            Value::Number(x) => format!("    --{}: {};\n", v.0, x),
            _ => panic!("Only strings and numbers have been implemented for"),
        };
        &file.write_all(x.as_bytes()).expect("failed to write");
    }
    if is_last {
        &file.write_all("}\n".as_bytes())?;
    }
   Ok(())
}

fn create_js_files(name: &str, value: &Value, path: &PathBuf) -> Result<()> {
    let mut file_css = File::create(format!("{}/{}.js", &path.to_string_lossy(), &name))?;
    file_css.write_all(format!("// {}\n\n", DONT_EDIT_COPY).as_bytes())?;
    file_css.write_all("export default {\n".as_bytes())?;
    for v in value.as_object().expect("Failed to parse value") {
        file_css.write_all(format!("    {}: {},\n", v.0, v.1).as_bytes())?;
    }
    file_css.write_all("}\n".as_bytes())?;
    Ok(())
}

fn main() -> Result<()> {
    let opt = Opt::from_args();
    let mut file = File::open(&opt.input)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let c: Value = serde_json::from_str(&contents)?;
    let root = c.as_object().expect("Provided file is not a json");
    for (index, (key, value)) in root.iter().enumerate() {
        if opt.output_scss.is_some() {
            create_scss_files(key, value, &opt.output_scss.clone().unwrap())?;
        }
        if opt.output_css.is_some() {
            let last_value = index == root.len() - 1;
            create_css_files(value, &opt.output_css.clone().unwrap(), last_value)?;
        }
        if opt.output_js.is_some() {
            create_js_files(key, value, &opt.output_js.clone().unwrap())?;
        }
    }
    Ok(())
}
